%% lithie-util.sty
%%
%% --------------------------------------------------------------------------
%%
%% Autor: Florian Sihler, 20.09.2020
%%
%% Collection of all the other packages i have, which are requsted as needed.
%%
\ProvidesPackage{lithie-util}[2020/09/20 v1.0 the lithie util collector]

\RequirePackage{kvoptions,etoolbox}

\SetupKeyvalOptions{family=LITU,prefix=LITU@}

\def\lithie@util@empty{}
\def\lithie@util@none{LITHIE@NO@OPTION@GIVEN}

\def\@lithie@hook@PackageRequire{}
\def\@lithie@hook@GroupRequire{}
\def\@lithie@hook@RequirePackages{}

\def\@lithie@all@groups{}

% add to list
\let\@lithie@util@atl\listadd

% #1 group id
\def\lu@DefineGroup#1{%
    \@namedef{@lithie@@group@#1}{}%
    \@lithie@util@atl\@lithie@all@groups{#1}%
    \DeclareVoidOption{#1}{%
        \typeout{Requested group '\CurrentOption'}\listadd\@lithie@hook@GroupRequire{#1}}
}

\def\lu@AddToGroup#1#2{\expandafter\def\expandafter\@lithie@tmp@listnam\expandafter{\csname @lithie@@group@#1\endcsname}%
\edef\@lithie@tmp{\noexpand\@lithie@util@atl\expandonce{\@lithie@tmp@listnam}{#2}}\@lithie@tmp%
}

\def\lu@LoadGroup#1{%
\typeout{Effective group load for: #1 (\@nameuse{@lithie@@group@#1})}%
\protected@edef\@lithie@tmp@groupload{\noexpand\forlistloop{\noexpand\lu@LoadModule}{\@nameuse{@lithie@@group@#1}}}%
\@lithie@tmp@groupload%
}

\def\@@lu@atgs#1#2{\lu@AddToGroup{#2}{#1}}

\def\lu@AddToGroups#1#2{\edef\@lithie@tmp{#2}%
    \protected@edef\@lithie@tmp@curcsv{\noexpand\forcsvlist{\noexpand\@@lu@atgs{\@lithie@tmp}}{#1}}\@lithie@tmp@curcsv%
}

\def\lu@Get#1#2{\@nameuse{@lu@module@map@#2@#1}}

% TODO: maybe avoid duplicate loading; maybe group commands to avoid pollution?
\def\@lithie@resolve@module@args#1#2#3{%
\edef\@lithie@name{\lu@Get{#1}{name}}% todo only expand once
\edef\@lithie@util@cur{\@nameuse{LITU@\@lithie@name}}%
\ifx\@lithie@util@cur\lithie@util@none#2\else#3\fi}

\def\@@lithie@util{:}
\def\@@lithie@util@load@consume@arg@ifcmd#1#2->#3#4{%
    \ifstrempty{#1#2}{}{%
        \def\@@lithie@first@chk{#1}%
        \ifx\@@lithie@first@chk\@@lithie@util% is command
            #3{#2}\else#4{#2}\fi%
    }%
}

\def\@lithie@cmd@defaults{defaults}
\def\@@lithie@passopt@fp#1#2{\PassOptionsToPackage{#1}{#2}}
% #1 id of current module, #2 command
\def\@lithie@util@execute@command#1#2{%
    \def\@@lithie@cmd@chk{#2}%
    \ifx\@@lithie@cmd@chk\@lithie@cmd@defaults%
        \edef\@lithie@tmp{\noexpand\@@lithie@passopt@fp{\lu@Get{#1}{defaults}}{\lu@Get{#1}{library}}}%
        \@lithie@tmp%
    \fi%
}

\def\@lithie@gobble#1{}
% allow ':defaults' to be used for defaults
\def\@@lithie@util@load@consume@arg#1#2#3{%
\@@lithie@util@load@consume@arg@ifcmd#3->{%
\@lithie@util@execute@command{#2}% is command
}{ % is no command
\PassOptionsToPackage{#3}{#1}\@lithie@gobble%
}}

\def\@lithie@util@load@curargs#1{%
    \edef\@lithie@tmp{\noexpand\forcsvlist{\noexpand\@@lithie@util@load@consume@arg{%
            \lu@Get{#1}{library}}{#1}}{\@lithie@util@cur}}%
    \@lithie@tmp%
}

\def\@lu@RequirePackage#1{%
% allow others PassOptionsToPackage to be called by other hooks:
\appto\@lithie@hook@RequirePackages{\typeout{Loading Library \lu@Get{#1}{library} for '#1'}%
\RequirePackage{\lu@Get{#1}{library}}}}

\def\lu@LoadModule#1{%
\@lithie@resolve@module@args{#1}{}{%
\@lithie@util@load@curargs{#1}%
}\@lu@RequirePackage{#1}% should be outside to execute always
}

\def\lu@LoadModuleIfGiven#1{%
\@lithie@resolve@module@args{#1}{}{%
\@lithie@util@load@curargs{#1}%
\@lu@RequirePackage{#1}% should be inside to execute only if
}}

% #1 internal name
% #2 module name
% #3 library to load
% #4 default options for the libary
% #5 list of groups to register (always all)
\def\lu@DefineModule#1#2#3#4#5{%
    \@namedef{@lu@module@map@name@#1}{#2}%
    \@namedef{@lu@module@map@library@#1}{#3}%
    \@namedef{@lu@module@map@defaults@#1}{#4}%
    \@namedef{@lu@module@map@groups@#1}{all,#5}%
    \protected@edef\@lithie@tmp{\noexpand\DeclareStringOption[\lithie@util@none]{\lu@Get{#1}{name}}[\lu@Get{#1}{defaults}]}\@lithie@tmp%
    \appto\@lithie@hook@PackageRequire{%
        \lu@LoadModuleIfGiven{#1}%
    }%
    \lu@AddToGroups{\lu@Get{#1}{groups}}{#1}%
}


\lu@DefineGroup{all}
\lu@DefineGroup{color}
\lu@DefineGroup{util}
\lu@DefineGroup{generic}
\lu@DefineGroup{sopra}
\lu@DefineGroup{uml}

% TODO: configurations or profiles which will setup some general options like add them to packages

\lu@DefineModule{cps}{color-palettes}{color-palettes}{}{color,util,generic}
\lu@DefineModule{lsc}{lecture-shortcuts}{lecture-shortcuts}{}{util}

\lu@DefineModule{sot}{sopra-tables}{sopra-tables}{}{sopra}
% is too specialiced to load with the group
% \lu@DefineModule{sos}{sopra-standard}{sopra-standard}{}{sopra}
\lu@DefineModule{sor}{sopra-requirements}{sopra-requirements}{}{sopra}
\lu@DefineModule{som}{sopra-models}{sopra-models}{}{sopra,uml}
\lu@DefineModule{sol}{sopra-listings}{sopra-listings}{noloadlangs}{sopra}
\lu@DefineModule{sod}{sopra-documentation}{sopra-documentation}{}{sopra}
\lu@DefineModule{sod}{sopra-changelog}{sopra-changelog}{}{sopra}
\lu@DefineModule{soa}{sopra-attachments}{sopra-attachments}{}{sopra}

\def\@@lithie@util@status@module#1{\lu@Get{#1}{name} (#1); }
\def\@@lithie@util@status#1{%
\edef\@lithie@tmploop{\noexpand\forlistloop{\noexpand\@@lithie@util@status@module}{\@nameuse{@lithie@@group@#1}}}
 \item[#1] \@lithie@tmploop%
}
\def\@lithie@util@status{%
Recognized groups: \forlistloop{ }{\@lithie@all@groups}%
% will always be 'all' list :D
\begin{description}\item\forlistloop{\@@lithie@util@status}{\@lithie@all@groups}\end{description}
}


\let\lustatus\@lithie@util@status


\ProcessKeyvalOptions*

% Load individuals first to allow options
\@lithie@hook@PackageRequire%
% Now load the groups.
\forlistloop{\lu@LoadGroup}{\@lithie@hook@GroupRequire}%

\@lithie@hook@RequirePackages\relax

\endinput